# JavaGC

Java内存分为以下几种：

- 寄存器：程序人员无法控制；
- 静态域：static定义的静态成员；
- 常量池：编译时被确定保存在.class文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）；
- 非RAM存储：硬盘等永久存储空间；
- 堆内存：new 创建的对象和数组，由Java虚拟机自动垃圾回收器管理，存取速度慢；
- 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小和生存期必须确定，缺乏灵活性。

Java堆：

- JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配 内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 
- 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之 前，他们会一直占据堆内存空间。

GC：

- GC 是垃圾收集的意思（GabageCollection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或 系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。
-  在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行扫描那些没有被任何引用的对象， 并将它们添加到要回收的集合中，进行回收。

垃圾判定：

- 引用计数：
  - 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用， 也就是“死对象”,将会被垃圾回收。
  - 缺点：无法解决对象循环引用，主流的虚拟机均没有采用这种算法。
- 根可达算法：
  - 从一个被称为 GC Roots 的对象开始向下搜索， 如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
  - GC Roots对象：
    - 虚拟机栈中引用的对象；
    - 方法区中静态属性引用的对象；
    - 方法区常量池引用的对象；
    - 本地方法JNI引用的对象；
- 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要 被真正的回收需要经历两次标记。
- 如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机 调用过，那么就认为是没必要的。 
- 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。 
- 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行， 不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的 对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对 象或所有对象进行垃圾回收。

垃圾回收机制：

- MinorGC和MajorGC
  - MinorGC发生在新生代的Eden区；
  - MajorGC主要是永久代满了会超过临界值，触发FullGC；
  - Java 8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区。 
- 标记 - 清除：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种 方法很简单，但是会有两个主要问题： 
  - 效率不高，标记和清除的效率都很低； 
  - 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作；
- 复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一半的内存。 
  - 将内存区域按 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区， 若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这 些对象通过分配担保机制复制到老年代中。（java 堆又分为新生代和老年代）
- 标记 - 整理：该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。 它的不同之处就是在清除对象的时候现将可回收对象移动到一端， 然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
- 分代收集：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。 

垃圾回收原理：

- 对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是” 可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。
- 内存泄漏的可能性：
  - 内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中；
  - 由于 Java 使用有向图的方式进行垃圾回收管理， 可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC就能回收。
  - Java 中的内存泄露的情况：
    - 长生命周期的对象持有短生命周期对 象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这 就是 Java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对 象放在缓存中 (例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 
    - 如果一个外部类的实例对象的方法返回了一个内部类的实例对象， 这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 
- System.gc()与Runtime.gc()：提示JVM进行垃圾回收。

深拷贝与浅拷贝：

- 浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员 或者指针就会报错；
- 深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间；

 